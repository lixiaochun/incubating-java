package im.wangbo.bj58.wconfig.core;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

import java.util.List;
import java.util.Map;
import java.util.function.Function;

import javax.json.Json;
import javax.json.JsonObjectBuilder;

/**
 * TODO add brief description here
 *
 * Copyright Â© 2016 58ganji Beijing spat team. All rights reserved.
 *
 * @author Elvis Wang [wangbo12 -AT- 58ganji -DOT- com]
 */
final class Util {
    private Util() {
        throw new AssertionError("Construction forbidden");
    }

    /**
     * Create a Json from a list of keys and a function generate value for each keys.
     *
     * Each key in {@code keys} will be added into the generated Json sequentially in order, thus
     * for duplicate keys, the latter one would override the former one.
     *
     * If the value generated by {@code valueFunc} for either key is null, that key would be skipped.
     *
     * The keys may be hierarchical with the use of {@code keySplitter}, which means a key may
     * represent a key in a multi level json.  For example, by using
     * {@code keySplitter = Splitter.on('.')}, the key "group.sub_group.name1" and its associated
     * value "value1" refers:
     *
     * {
     *     "group": {
     *         ...
     *         "sub_group":{
     *             "name1": "value1"
     *         }
     *         ...
     *     }
     * }
     *
     * With {@code keySplitter}, multi keys with same category names may be merged or overridden.
     *
     * 1. ["group1.sub_group1.name1" -> "value1", "group1.sub_group1.name2" -> "value2"]
     * would be merged as:
     *
     * {
     *     "group1": {
     *         ...
     *         "sub_group1":{
     *             "name1": "value1",
     *             "name2": "value2"
     *         }
     *         ...
     *     }
     * }
     *
     * 2. ["group1.sub_group1" -> "value1", "group1.sub_group1.name2" -> "value2"]
     * would be merged as:
     *
     * {
     *     "group1": {
     *         ...
     *         "sub_group1":{
     *             "name1": "value1",
     *             "name2": "value2"
     *         }
     *         ...
     *     }
     * }
     *
     * @param keys
     * @param valueFunc
     * @param keySplitter
     * @return
     */
    static JsonObjectBuilder transform(
            final Iterable<String> keys,
            final Function<String, String> valueFunc,
            final Splitter keySplitter
    ) {
        final Map<String, Object> map = Maps.newHashMap();

        for (final String key : keys) {
            final String val = valueFunc.apply(key);
            if (null == val) continue;

            final List<String> sepKeys = keySplitter.splitToList(key);
            Map<String, Object> tempMap = null;
            for (int i = sepKeys.size() - 1; i >= 0; i--) {
                if (null == tempMap) {
                    tempMap = ImmutableMap.of(sepKeys.get(i), val);
                } else {
                    tempMap = ImmutableMap.of(sepKeys.get(i), tempMap);
                }
            }

            if (null != tempMap) {
                merge(map, tempMap);
            }
        }

        final JsonObjectBuilder builder = Json.createObjectBuilder();
        collect(map, builder);
        return builder;
    }

    @VisibleForTesting
    static void collect(final Map<String, Object> map, final JsonObjectBuilder builder) {
        for (final Map.Entry<String, Object> entry : map.entrySet()) {
            final String k = entry.getKey();
            final Object v = entry.getValue();

            if (v instanceof Map) {
                final JsonObjectBuilder subBuilder = Json.createObjectBuilder();
                collect(Map.class.cast(v), subBuilder);
                builder.add(k, subBuilder);
            } else if (v instanceof String){
                builder.add(k, String.class.cast(v));
            } else {
                // Skip and do nothing
            }
        }
    }

    @VisibleForTesting
    static void merge(final Map<String, Object> base, final Map<String, Object> patch) {
        for (final Map.Entry<String, Object> entry : patch.entrySet()) {
            final String k = entry.getKey();
            final Object v = entry.getValue();

            final Object baseV = base.get(k);
            if (baseV instanceof Map) {
                if (v instanceof Map) {
                    merge(Map.class.cast(baseV), Map.class.cast(v));
                } else {
                    merge(Map.class.cast(baseV), ImmutableMap.of("", v));
                }
            } else {
                base.put(k, v);
            }
        }
    }
}
